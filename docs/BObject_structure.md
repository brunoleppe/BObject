# BObject Implementation
This section describes the BObject and Type System Implementation.
## BObject
BObject is the base data type and consists of a single public field, the type ID. 
The BObjectClass consists of a single virtual method: delete.

## Type System
The Type System consists of an array of TypeNodes that contain the type's information in the form of struct fields. 
These fields describe the type's ID, size, class' size, interfaces, private structure size, private offset, class initializer
and object initializer.   

The Type System is in charge of creating and initializing object instances, creating and initializing classes, registering
interfaces and providing inheritance mechanisms. The Type System is also in charge of deleting objects and cleaning the memory used
by itself.

**Note1:** BObject implementation was designed as simple as possible, it does not implement full OOP as expected from a 
fully OOP oriented language as Java or C#. many things were left behind, although I 
think that it's possible to extend the Type System to include some of these.

**Note2:** BObject does not copy the GObject's implementation.

## [Basic OOP concepts in the C language](BasicOOP.md)

## Public and Private Fields
How to implement both public and private data for an object structure? The former implementation of data encapsulation makes it
impossible to define a structure with both private and public data due to the C language's restrictions.

Another implementation is needed and this is something that GObject solved by having an additional "private" structure defined in the object's
source file. So, how do this work on BObject? Some mechanism is needed to "join" both structures as one, and this is achieved 
by adding both struct sizes. 

We can visualize what's happening with this diagram:
This represents the memory block of the "public" struct
```
|++++++++|
|++++++++|
```

and this represents the memory block of the "private" struct
```
|........|
|........|
|........|
```

To join them, we just need to add their sizes; then, the Type System will allocate a memory block with the total size, creating a block like this:
```
|        |
|        |
|        |
|        |
|        |
```

Then we need to provide an offset to divide the two structs. BObject always divide the block placing the private data "above" the public data.
This helps with inheritance of both public and private data. Note that private data "can't" be inherited, as the private struct is defined
in the source file, nobody can access the struct definition. 
The allocated memory block will be seen as this by the Type System:
```
|........|
|........|
|........|----> here's the offset value
|++++++++|
|++++++++|
```

When creating an object, the returned pointer will be offset a positive amount to point to the public data. When accessing 
the private data the object's pointer will be offset by a negative amount to be placed at the origin of the block, 
the position of the private data.
This offset is provided by the Type System when registering a new type with private data. A getter function for the 
private data is generated by the Type System macros B_DEFINE_...

## Data Inheritance
Inheritance is achieved by embedding the parent's data structure in the child's data structure.
```
|.............|
|Parent's data|
|.............|
|+++++++++++++|
|Child's data |
|+++++++++++++|
```
What about private data? As private data can't be inherited, the Type System utilizes the total size of the parent object
to define the new type. Thus, the child's size is `size = public_size + (parent_size + parent_private_size)` and can be 
extended with it's own private size `size = public_size + private_size + (parent_total_size)`. With the size set, the Type
System provides the new private offset of the new type.

## Type Classes

Classes are implmented as C structs with function pointers. When registering a new type, the class' size is provided to 
the Type System. The Type System allocates memory for the type's class and is initialized with the class initializer 
function. Only one class structure is created per type.

The class structure pointer is assigned to a member of a type's TypeNode. When accessing the type's class, the type ID is
needed, then the Type System obtains the specific TypeNode through the type ID and returns the class pointer.  

## Interfaces and Class Extensions
Interfaces are implemented in a similar manner as data inheritance. When a type implements an interface, it's class size
is increased with the size of the interface. Every interface implemented increases the class' size. 

Interfaces are stored inside a list of interfaces unique to each type. A node is generated with every implemented interface.
The interface offset is stored, as well as the interface pointer and the initializer function. 

The resulting class structure can be visualized as follows:
```
|........|----> Interface 1
|........|
|++++++++|----> Interface 2
|********|----> Object's class
|********|

```

A type that derives form an interface implementor type, the interface data is assigned to the new type. In other words, 
both types share the same pointer. No new data is created. 

When the derived type overrides or implements a new interface, a new interface list is created, the parent interface
list is copied, and overrided if needed, and new nodes are created for the implemented interfaces. Finally, the type's 
class is created and initialized.